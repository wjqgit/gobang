<!DOCTYPE html>
<html>

<head>
  <title>kovansystem Movement Demo</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="css/main.css">

  <script src="js/socket.io/socket.io.js"></script>

  <script src="js/three.min.js"></script>
  <script src="js/Detector.js"></script>
  <script src="js/controls/TrackballControls.js"></script>
  <script src="js/libs/stats.min.js"></script>

  <script src="js/Path.js"></script>

  <script src="js/BaseRail.js"></script>
  <script src="js/StraightRail.js"></script>
  <script src="js/CurvedRail.js"></script>

  <script src="js/BaseBox.js"></script>
  <script src="js/Rack.js"></script>
  <script src="js/Mover.js"></script>
</head>

<body>
  <script>
    var port = 9002;
    var socket = io.connect('http://localhost:' + port);

    socket.on('connect', function() {
      console.log('Connected to server at port: %d', port);
    })

    socket.on('send_map', function(map) {
      console.log('Received map from server!');
      buildWarehouse(map.nodes);
      initializeMover();
    })

    socket.on('send_path', function(path) {
      console.log('Received path from server!');
      executePath(path.nodes);
    })

    if(!Detector.webgl)Detector.addGetWebGLMessage();

    // PARAMS WAREHOUSE
    var FLOOR_WIDTH = 50000; // x
      FLOOR_DEPTH = 50000; // y

    // PARAMS GRAPHICS
    var MARGIN = 0;

    var SCREEN_WIDTH = window.innerWidth,
      SCREEN_HEIGHT = window.window.innerHeight - 2 * MARGIN;

    // COMPONENTS GRAPHICS
    var container, info, stats;

    var renderer, scene, camera, control;

    var ambientLight, directionalLight;

    var grid_geometry, grid_material, grid;

    var rails = new THREE.Mesh();

    var mover;

    var path;

    // FPS
    var fps = 0, startTime = Date.now(), prevTime = startTime, frames = 0;

    init();
    animate();

    function init() {
      // CONTAINER
			container  = document.createElement('div');
			document.body.appendChild(container);

			// INFO
			info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Kovan System - Movement by wjq';
			info.innerHTML += '<br/><br/><input id="RequestMap" type="button" onClick="requestMap()" value="Request Map"/>';
      info.innerHTML += '<br/><br/><input id="RequestPath" type="button" onClick="requestPath()" value="Request Path"/>';

			container.appendChild(info);

			// GRID
			var step = 1000;
			grid_geometry = new THREE.Geometry();

			for ( var i = 0; i <= FLOOR_WIDTH; i += step) {
				grid_geometry.vertices.push(new THREE.Vector3( i, 0, 0 ));
				grid_geometry.vertices.push(new THREE.Vector3( i, FLOOR_DEPTH, 0 ));
			}

			for ( var j = 0; j <= FLOOR_DEPTH; j += step ) {
				grid_geometry.vertices.push(new THREE.Vector3( 0, j, 0 ));
				grid_geometry.vertices.push(new THREE.Vector3( FLOOR_WIDTH, j, 0 ));
			}

			grid_material = new THREE.LineBasicMaterial( { color : 0xffffff, opacity: 0.4, transparent: true});

			grid = new THREE.LineSegments( grid_geometry, grid_material);

      // LIGHT
			ambientLight = new THREE.AmbientLight( 0x606060 );

			directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
			directionalLight.position.set(-1, 1, 1);

			// RENDERER
			renderer = new THREE.WebGLRenderer( {
				antialias: true
			} );

			renderer.shadowMap.enabled = true;

			// SCENE
			scene = new THREE.Scene();

			// CAMERA
			camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH/SCREEN_HEIGHT, 1, 200000 );
			camera.position.set(FLOOR_WIDTH / 2, - FLOOR_DEPTH / 2, FLOOR_DEPTH / 3);

			// CONTROL
			control = new THREE.TrackballControls( camera );

			control.rotateSpeed= 1.0;
			control.zoomSpeed = 1.2;
			control.panSpeed = 1.0;

			control.noZoom = false;
			control.noPan = false;

			control.staticMoving = true;
			control.dynamicDampingFactor = 0.3;

			control.keys = [65, 83, 68]; //rotateKey, zoomKey, panKey

			control.target =new THREE.Vector3( FLOOR_WIDTH / 2, FLOOR_DEPTH / 2, 0 ) ; //confliction of camera and control, do not use camera.lookAt.

			// ADD MESH TO SCENE
			scene.add(grid);

			scene.add(ambientLight);
			scene.add(directionalLight);

			// RENDERER SETUP
			renderer.setClearColor( 0x000000 );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			container.appendChild(renderer.domElement);

			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			// LISTENER

			// RESIZE LISTENER
			window.addEventListener('resize', onWindowResize, false);
    }

    function buildWarehouse(nodes) {
      if (rails.children.length > 0) return;

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];

        if ( node.radius == -1) {
          var pointA = new THREE.Vector3(node.pointALocation.x,
              node.pointALocation.y,node.pointALocation.z),
              pointB = new THREE.Vector3(node.pointBLocation.x,
              node.pointBLocation.y,node.pointBLocation.z);

          var rail = new THREE.StraightRail(pointA, pointB);
          rail.name = node.railSeq;
          rail.speedLimit = node.speedLimit;
          rails.add(rail);
        } else {
          var center = new THREE.Vector3(node.centerLocation.x,
              node.centerLocation.y, node.centerLocation.z);

          var startAngle = Math.PI * node.startAngle / 180,
              endAngle = Math.PI * node.endAngle / 180;

          var rail = new THREE.CurvedRail(center, node.radius,
              startAngle, endAngle, node.clockwise);

          rail.name = node.railSeq;
          rail.speedLimit = node.speedLimit;
          rails.add(rail);
        }
      }
      scene.add(rails);
      console.log("Digital map is SUCCESSFULLY loaded!");
    }

    function initializeMover() {
      mover = new THREE.Mover();
      mover.position.copy(rails.getObjectByName("rail-io-0-00").pointA);
      mover.rotation.z += Math.PI / 2;

      scene.add(mover);
    }

    function executePath(nodes) {
        var waypoints = []
        for(var i = 0; i < nodes.length; i++) {
          waypoints[i] = rails.getObjectByName(nodes[i].railSeq);
        }
        path = new Path(waypoints);
    }

    function requestMap() {
      socket.emit('request_map', {})
    }

    function requestPath() {
      var msg = {}
      msg.startNodeSeq = "unit-0";
      msg.goalNodeSeq = "dock-station-1";
      socket.emit('request_path', msg)
    }

    function updateFPS() {
			var time = Date.now();
			frames ++;

			if(time > prevTime + 200) {
				fps = roundTo(((frames * 1000) / (time - prevTime)), 3);

				prevTime = time;
				frames = 0;
			}

			return time;
		}

    function roundTo(x, d) {
      return +(Math.round(x + "e+" + d) + "e-" + d); // append "e+3" equals to multiply the number by 1000, and +() convert a string back to number.
    }

    function onWindowResize() {
      SCREEN_WIDTH = window.innerWidth;
      SCREEN_HEIGHT = window.innerHeight;

      camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
      camera.updateProjectionMatrix();

      renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    }

    function animate() {
      requestAnimationFrame(animate);
      startTime = updateFPS();
      if (path != null) mover.executePath(fps, path);
      render();
    }

    function render() {
      control.update();
      stats.update();
      renderer.render(scene, camera);
    }

  </script>
</body>

</html>
