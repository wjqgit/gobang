<!DOCTYPE html>
<html>
<head>
	<title>kovansystem visulization - test modularization</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body ontouchstart="">
	<link rel="stylesheet" href="/public/css/main.css">

	<script src="/socket.io/socket.io.js"></script>

	<script src="/public/js/three.min.js"></script>
	<script src="/public/js/Detector.js"></script>
	<script src="/public/js/controls/TrackballControls.js"></script>
	<script src="/public/js/libs/stats.min.js"></script>

	<script src="/public/js/Path.js"></script>

	<script src="/public/js/BaseRail.js"></script>
	<script src="/public/js/StraightRail.js"></script>
	<script src="/public/js/CurvedRail.js"></script>

	<script src="/public/js/BaseBox.js"></script>
	<script src="/public/js/Rack.js"></script>
	<script src="/public/js/Mover.js"></script>
	
	<script>
		var io = io(); 

		io.on('connect', function () {
			console.log('Connected to server.');
			
			init();
			buildWarehouse();
			animate();
		});

		if(!Detector.webgl)Detector.addGetWebGLMessage();

		// PARAMS WAREHOUSE
		var FLOOR_WIDTH = 50000; // x 
			FLOOR_DEPTH = 50000; // y

		// PARAMS GRAPHICS
		var MARGIN = 0;

		var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.window.innerHeight - 2 * MARGIN;

		// COMPONENTS GRAPHICS
		var container, info, stats;

		var renderer, scene, camera, control;

		var ambientLight, directionalLight;

		var grid_geometry, grid_material, grid;

		var light_x = -1, flag = 'add';

		var rack;

		var mover;

		var rail1, c_rail, rail2;

		var rails; 

		var path;

		// FPS
		var fps = 0, startTime = Date.now(), prevTime = startTime, frames = 0;

		function init() {
			// CONTAINER
			container  = document.createElement('div');
			document.body.appendChild(container);

			// INFO
			info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Kovan System - Movement by wjq';
			info.innerHTML += '<br/><br/><input id="reset" type="button" onClick="reset()" value="Reset"/>';

			container.appendChild(info);

			// GRID
			var step = 1000;
			grid_geometry = new THREE.Geometry();
			
			for ( var i = 0; i <= FLOOR_WIDTH; i += step) {
				grid_geometry.vertices.push(new THREE.Vector3( i, 0, 0 ));
				grid_geometry.vertices.push(new THREE.Vector3( i, FLOOR_DEPTH, 0 ));
			}

			for ( var j = 0; j <= FLOOR_DEPTH; j += step ) {
				grid_geometry.vertices.push(new THREE.Vector3( 0, j, 0 ));
				grid_geometry.vertices.push(new THREE.Vector3( FLOOR_WIDTH, j, 0 ));
			}

			grid_material = new THREE.LineBasicMaterial( { color : 0xffffff, opacity: 0.4, transparent: true});

			grid = new THREE.LineSegments( grid_geometry, grid_material);


			// LIGHT
			ambientLight = new THREE.AmbientLight( 0x606060 );

			directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
			directionalLight.position.set(light_x, 1, 1);

			// RENDERER
			renderer = new THREE.WebGLRenderer( {
				antialias: true
			} );

			renderer.shadowMap.enabled = true;

			// SCENE
			scene = new THREE.Scene();

			// CAMERA
			camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH/SCREEN_HEIGHT, 1, 200000 );
			camera.position.set(FLOOR_WIDTH / 2, - FLOOR_DEPTH / 2, FLOOR_DEPTH / 3);

			// CONTROL
			control = new THREE.TrackballControls( camera );

			control.rotateSpeed= 1.0;
			control.zoomSpeed = 1.2;
			control.panSpeed = 1.0;

			control.noZoom = false;
			control.noPan = false;

			control.staticMoving = true;
			control.dynamicDampingFactor = 0.3;

			control.keys = [65, 83, 68]; //rotateKey, zoomKey, panKey

			control.target =new THREE.Vector3( FLOOR_WIDTH / 2, FLOOR_DEPTH / 2, 0 ) ; //confliction of camera and control, do not use camera.lookAt.

			// ADD MESH TO SCENE
			scene.add(grid);

			scene.add(ambientLight);
			scene.add(directionalLight);

			// RENDERER SETUP
			renderer.setClearColor( 0x000000 );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			container.appendChild(renderer.domElement);		
			
			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			// LISTENER

			// RESIZE LISTENER
			window.addEventListener('resize', onWindowResize, false);
		}

		function buildWarehouse() {
			// RACK
			rack = new THREE.Rack();

			// MOVER
			mover = new THREE.Mover();

			// STRAIGHT RAIL
			var pointA = new THREE.Vector3( FLOOR_WIDTH / 2 - 15000, FLOOR_DEPTH / 2, 2000),
				pointB = new THREE.Vector3( FLOOR_WIDTH / 2 + 15000, FLOOR_DEPTH / 2, 2000);

			rail1 = new THREE.StraightRail(pointA, pointB);

			// CURVED RAIL
			var radius = 1400;
			var center = pointB.clone();
			center.y -= radius;
 
			c_rail = new THREE.CurvedRail(center, radius, Math.PI / 2, Math.PI * 2, true);

			// ANOTHER STRAIGHT RAIL
			pointA.copy(pointB);
			pointA.x += radius;
			pointA.y -= radius;
			pointB.x += radius;
			pointB.y -= ( radius + 10000);
			rail2 = new THREE.StraightRail(pointA, pointB);

		  	rails = [rail1, c_rail, rail2];
		  	// console.log(rails.length);
		  	// console.log(rails[0]);
		  	path = new Path(rails);

			mover.position.copy(rail1.pointA);

			scene.add(rack);
			scene.add(mover);
			scene.add(rail1);
			scene.add(rail2);
			scene.add(c_rail);
		}

		function reset() {
			mover.reset();
		}

		function updateFPS() {
			var time = Date.now();
			frames ++;

			if(time > prevTime + 200) {
				fps = roundTo(((frames * 1000) / (time - prevTime)), 3);

				prevTime = time;
				frames = 0;
			}

			return time;
		}

		function roundTo(x, d) {
			return +(Math.round(x + "e+" + d) + "e-" + d); // append "e+3" equals to multiply the number by 1000, and +() convert a string back to number.
		}

		function onWindowResize() {
			SCREEN_WIDTH = window.innerWidth;
			SCREEN_HEIGHT = window.innerHeight;

			camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			camera.updateProjectionMatrix();

			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		}

		function animate() {
			requestAnimationFrame(animate);
			startTime = updateFPS();
			mover.executePath(fps, path);
			render();
		}

		function render() {
			control.update();
			stats.update();
			renderer.render(scene, camera);
		}

	</script>
</body>
</html>