<!DOCTYPE html>
<html>
<head>
	<title>kovansystem movement test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src="/public/js/three.min.js"></script>
	<script src="/public/js/Detector.js"></script>
	<script src="/public/js/controls/TrackballControls.js"></script>
	<script src="/public/js/libs/stats.min.js"></script>
	<style>
		body {
			font-family: monospace;
			color: #ccc;

			background-color: #fff;
			margin: 0px; 
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script >
		if(!Detector.webgl)Detector.addGetWebGLMessage();

		//PARAMS WAREHOUSE
		var BAY_TOTAL =  12, 
			FLOOR_TOTAL = 6,
			UNIT_TOTAL = BAY_TOTAL * FLOOR_TOTAL, // 72
			PICKER_TOTAL = UNIT_TOTAL, // 72
			// MOVER_TOTAL = 300,
			RACK_PER_ROW = 100,
			VT_TOTAL = 2,
			STATION_PER_FLOOR = 5,
			STATION_FLOOR_TOTAL = 3,
			STATION_TOTAL = STATION_PER_FLOOR * STATION_FLOOR_TOTAL;

		var RACK_HEIGHT = 1800,
			RACK_WIDTH = 1000,
			RACK_DEPTH = 500,
			RACK_SPACING = 50,
			RACK_ROW_DISTANCE = 2000,
			UNIT_HEIGHT = 2000,
			UNIT_WIDTH =  3500,
			UNIT_DEPTH =  ( RACK_DEPTH + RACK_SPACING) * RACK_PER_ROW,
			BAY_TOTAL_WIDTH = UNIT_WIDTH * BAY_TOTAL,
			BAY_HEIGHT = UNIT_HEIGHT * FLOOR_TOTAL,
			FLOOR_WIDTH = 45000,
			FLOOR_DEPTH = 60000;
			BEAM_IO_LENGTH = 1000;
			BEAM_STATION_LENGTH = BEAM_IO_LENGTH;
			RAILWAY_WIDTH = 2000;
			STATION_WIDTH = 3000;
			STATION_DISTANCE = UNIT_WIDTH * 2;

		var BAY_DATUM_X = 1500,
			BAY_DATUM_Y = 0,
			BAY_DATUM_Z = -5000,
			STATION_DATUM_X = BAY_DATUM_X + UNIT_WIDTH * 2,
			STATION_DATUM_Y = 0,
			STATION_DATUM_Z = BAY_DATUM_Z + BEAM_IO_LENGTH + RAILWAY_WIDTH;

		// PARAMS GRAPHICS
		var MARGIN = 0;

		var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.window.innerHeight - 2 * MARGIN;

		// COMPONENTS GRAPHICS
		var container, info, stats;

		var renderer, scene, camera, control;

		var ambientLight, directionalLight;

		var grid_geometry, grid_material, grid;

		var pillar_geometry, beam_x_geometry, beam_z_geometry, beam_rack_geometry,
			beam_picker_geometry, beam_io_geometry, beam_station_geometry, vt_geometry;

		var railway1_path, railway1_geometry,
			railway2_path, railway2_geometry,
			railway_l_geometry, railway_c_geometry;

		var rack_geometry, rack_material, //rack;
			station_geometry, station_material;

		var line_material;

		var racks = new THREE.Mesh(), 
			structure = new THREE.Mesh(), 
			railways = new THREE.Mesh(), 
			stations = new THREE.Mesh();

		var light_x = -1, flag = 'add';

		var view_angle = 0;

		var rack1_move, rack2_move;

		var speed1 = 1000, speed2 = 0; // 1m/s

		var count1 = 0, count2 = 0;

		var clock = 0;

		var fps = 0, startTime = Date.now(), prevTime = startTime, frames = 0;

		init();

		buildWarehouse();

		// var clock = Date.now();

		animate();

		

		function init() {
			// CONTAINER
			container  = document.createElement('div');
			document.body.appendChild(container);

			// INFO
			info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Kovan System - Movement by wjq';
			info.innerHTML += '<br/><br/>Speed <a onClick="speedUp()">+</a> / <a onClick="speedDown()">-  </a>';
			// info.innerHTML += '<br/><br/><input id="view" type="button" onClick="racks.visible = !racks.visible" value="View Racks"/>';
			info.innerHTML += '<input id="view" type="button" onClick="viewRacks(true)" value="View Racks: ON" />';


			container.appendChild(info)
			// GRID
			var step = 1000;
			grid_geometry = new THREE.Geometry();
			
			for ( var i = 0; i <= FLOOR_WIDTH; i += step) {
				grid_geometry.vertices.push(new THREE.Vector3( i, 0, 0 ));
				grid_geometry.vertices.push(new THREE.Vector3( i, 0, -FLOOR_DEPTH ));
			}

			for ( var j = 0; j <= FLOOR_DEPTH; j += step ) {
				grid_geometry.vertices.push(new THREE.Vector3( 0, 0, -j ));
				grid_geometry.vertices.push(new THREE.Vector3( FLOOR_WIDTH, 0, -j ));
			}

			grid_material = new THREE.LineBasicMaterial( { color : 0xffffff, opacity: 0.4, transparent: true});

			grid = new THREE.LineSegments( grid_geometry, grid_material);

			// STRUCTURE
			line_material = new THREE.LineBasicMaterial( { color : 0xffffff, opacity: 0.8, transparent: true} );

			// RACK
			rack_geometry = new THREE.BoxGeometry(RACK_WIDTH, RACK_HEIGHT, RACK_DEPTH);
			rack_material = new THREE.MeshLambertMaterial( {color: 0x666666} );

			// RAILWAY
			railway1_path = new THREE.CurvePath();
			railway1_path.add( new THREE.EllipseCurve(
				0, 0,
				RAILWAY_WIDTH / 2, RAILWAY_WIDTH / 2,
				Math.PI / 2,  - Math.PI / 2,
				false,
				0));
			railway1_path.add( new THREE.LineCurve(
				new THREE.Vector2( 0, - RAILWAY_WIDTH / 2 ), 
				new THREE.Vector2( BAY_TOTAL_WIDTH, - RAILWAY_WIDTH / 2 )));
			railway1_path.add( new THREE.EllipseCurve(
				BAY_TOTAL_WIDTH, 0,
				RAILWAY_WIDTH / 2, RAILWAY_WIDTH / 2,
				- Math.PI / 2, Math.PI / 2,
				false,
				0 ));
			railway1_path.closePath();
			// railway_path = new THREE.Path();
			// railway_path.moveTo( new THREE.Vector2( 0, RAILWAY_WIDTH / 2 ));
			// railway_path.absarc(0, 0, RAILWAY_WIDTH / 2, Math.PI / 2, 3 * Math.PI / 2, false);
			// railway_path.lineTo(BAY_TOTAL_WIDTH, RAILWAY_WIDTH / 2);
			// railway_path.arc(0, - RAILWAY_WIDTH / 2, RAILWAY_WIDTH / 2, Math.PI / 2, - Math.PI / 2, true);
			// railway_path.lineTo(0, - RAILWAY_WIDTH / 2);
			railway1_geometry = railway1_path.createPointsGeometry(1024);

			railway2_path = new THREE.CurvePath();
			railway2_path.add(new THREE.LineCurve(
				new THREE.Vector2( 0, 0 ),
				new THREE.Vector2( BAY_TOTAL_WIDTH, 0 )
			));
			railway2_geometry = railway2_path.createPointsGeometry(1024);
			
			// LIGHT
			ambientLight = new THREE.AmbientLight( 0x606060 );

			directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
			directionalLight.position.set(light_x, 1, 1);

			// RENDERER
			renderer = new THREE.WebGLRenderer( {
				antialias: true
			} );

			renderer.shadowMap.enabled = true;

			// SCENE
			scene = new THREE.Scene();

			// CAMERA
			camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH/SCREEN_HEIGHT, 1, 200000 );
			camera.position.set(FLOOR_WIDTH / 2, FLOOR_DEPTH / 6, FLOOR_DEPTH / 3);

			// CONTROL
			control = new THREE.TrackballControls( camera );

			control.rotateSpeed= 1.0;
			control.zoomSpeed = 1.2;
			control.panSpeed = 1.0;

			control.noZoom = false;
			control.noPan = false;

			control.staticMoving = true;
			control.dynamicDampingFactor = 0.3;

			control.keys = [65, 83, 68]; //rotateKey, zoomKey, panKey

			control.target =new THREE.Vector3( FLOOR_WIDTH / 2, 0, -FLOOR_DEPTH / 2 ) ; //confliction of camera and control, do not use camera.lookAt.

			// ADD MESH TO SCENE
			scene.add(grid);
			// scene.add(rack);

			scene.add(ambientLight);
			scene.add(directionalLight);

			// RENDERER SETUP
			renderer.setClearColor( 0x000000 );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			container.appendChild(renderer.domElement);		
			
			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);

			// LISTENER

			// RESIZE LISTENER
			window.addEventListener('resize', onWindowResize, false);
		}

		function buildWarehouse(){
			// GENERATE
			generateRacks();
			generateRailway();
			rack1_move = new THREE.Mesh(rack_geometry, rack_material);
			rack2_move = new THREE.Mesh(rack_geometry, rack_material);

			racks.visible = false;
			// ADD TO SCENE
			scene.add(racks);
			scene.add(railways);
			scene.add(rack1_move);
			scene.add(rack2_move);
			render();
		}

		function generateRailway() {
			// RAILWAY#1
			var railway1 = new THREE.Line(railway1_geometry, line_material);
			railway1.rotateX(- Math.PI / 2);
			railway1.position.set(
				BAY_DATUM_X,
				BAY_DATUM_Y + UNIT_HEIGHT,
				BAY_DATUM_Z + BEAM_IO_LENGTH + RAILWAY_WIDTH / 2
			);
			railway1.name = 'railway1';
			// console.log(railway.name);
			// railway.position.x = 2000;
			railways.add(railway1);

			// RAILWAY#2
			var railway2 = new THREE.Line(railway2_geometry, line_material);
			railway2.position.set(
				BAY_DATUM_X,
				BAY_DATUM_Y + UNIT_HEIGHT * 2,
				BAY_DATUM_Z + BEAM_IO_LENGTH + RAILWAY_WIDTH / 2
			);
			railway2.name = 'railway2';
			railways.add(railway2);
		}

		function generateRacks() {
			// RACKS
			for (var floor_count1 = 0; floor_count1 < FLOOR_TOTAL; floor_count1++) {
				for (var bay_count1 = 0; bay_count1 < BAY_TOTAL; bay_count1++){
					var railway = new THREE.Mesh();
					for (var i = 0; i < RACK_PER_ROW; i++) {
						for (var j = 0; j < 2; j++) {
							var rack = new THREE.Mesh( rack_geometry, rack_material);

							rack.position.set(
								BAY_DATUM_X + UNIT_WIDTH * bay_count1 + (UNIT_WIDTH - RACK_ROW_DISTANCE) / 2 + RACK_ROW_DISTANCE * j,
								BAY_DATUM_Y + UNIT_HEIGHT * (floor_count1 + 1) - RACK_HEIGHT / 2 ,
								BAY_DATUM_Z - (RACK_DEPTH + RACK_SPACING) * i - RACK_DEPTH / 2);

							racks.add(rack);

							// console.log(rack.position);
						}
					}
				}
			}
		}

		function speedUp () {
			speed1 += 1000;
			console.log('speed up to ' + speed1 + '!');
		}

		function speedDown() {
			if(speed1 > 0 ){
				speed1 -= 1000;
			}
			console.log('speed down to ' + speed1 + '...');
		}

		function accelerate(a) {
			a_converted = a / 60;
			speed2 += a_converted;
			console.log('speed 2: ' + speed2);
		}

		function move1() {
			// MOVE OBJECT
			var	distance = railway1_path.getLength(),				
				division = 10 * 1000,
				// increment = division * speed1 / (distance * 60); // 60 FPS
				increment = division * speed1 / (distance * fps); // Dynamic FPS

			var t = ( count1 % division ) / division;

			// LOCATION
			var point = railway1_path.getPointAt(t);

			rack1_move.position.copy(railways.getObjectByName('railway1').position);
			// console.log(rack1_move.position);
			rack1_move.position.x += point.x;
			rack1_move.position.y -= RACK_HEIGHT / 2;
			rack1_move.position.z += - point.y;

			// DIRECTION
			var dir = railway1_path.getTangentAt(t);
			var angle = Math.atan(dir.y / dir.x);
			rack1_move.rotation.y = angle;
			// console.log(angle);

			// CALCULATE NEXT STEP
			count1 += increment;
		}

		function move2() {
			var distance = railway2_path.getLength(),
				division = 10 * 1000,
				// increment = division * speed2 / (distance * 60); // Static FPS
				increment = division * speed2 / (distance * fps); // Dynamic FPS


			var t = ( count2 % division ) / division;

			var point = railway2_path.getPointAt(t);

			rack2_move.position.copy(railways.getObjectByName('railway2').position);
			rack2_move.position.x += point.x;
			rack2_move.position.y -= RACK_HEIGHT / 2;
			rack2_move.position.z += - point.y;

			// DIRECTION
			var dir = railway2_path.getTangentAt(t);
			var angle = Math.atan(dir.y / dir.x);
			rack2_move.rotation.y = angle;

			// CALCULATE NEXT STEP
			count2 += increment;

			// SPEED CHANGE
			var interval = 19 * 1000,
				time = clock  % interval;

			if ( 0 <= time && time <= 7000) {
				accelerate(500);
			} else if(12000 <= time && time <= 19000){
				accelerate(-500);
			}

			clock += 1000 / 60;
		}

		function viewRacks(toggle) {
			if(toggle){
				racks.visible = racks.visible === false;
				document.getElementById('view').value = 'View Racks: ' + (racks.visible ? 'OFF' : 'ON');
			}
		}

		function updateFPS() {
			var time = Date.now();
			frames ++;

			if(time > prevTime + 200) {
				fps = roundTo(((frames * 1000) / (time - prevTime)), 3);

				prevTime = time;
				frames = 0;
			}

			return time;
		}

		function roundTo(x, d) {
			return +(Math.round(x + "e+" + d) + "e-" + d); // append "e+3" equals to multiply the number by 1000, and +() convert a string back to number.
		}

		function onWindowResize() {
			SCREEN_WIDTH = window.innerWidth;
			SCREEN_HEIGHT = window.innerHeight;

			camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			camera.updateProjectionMatrix();

			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		}

		function animate() {
			requestAnimationFrame(animate);
			startTime = updateFPS();
			console.log(fps);
			move1();
			move2();
			render();
		}

		function render() {
			control.update();
			stats.update();
			renderer.render(scene, camera);
		}
	</script>
</body>
</html>